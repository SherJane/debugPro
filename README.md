web容器(tomcat、jetty等)查找ServletContainerInitializer的实现类，反映为spring-web包下的SpringServletContainerInitializer，查找WebApplicationInitializer的实现类。

A、web.xml存在时，通过文件指定ContextLoaderListener和DispatcherServlet

B、注解驱动时，由WebApplicationInitializer的实现类来添加ContextLoaderListener和DispatcherServlet（AbstractContextLoaderInitializer负责ContextLoaderListener，AbstractDispatcherServletInitializer负责DispatcherServlet）

ContextLoaderListener的作用，初始化spring容器，将容器与ServletContext关联起来；



web容器根据loadOnStartup参数择机调用Servlet的init方法，做子容器创建（web.xml时）、refresh等操作。之后DispatcherServlet初始化MVC所需组件。



refresh

1、prepareRefresh

​      initPropertySources()初始化属性源；如AbstractRefreshableWebApplicationContext，添加了ServletContext和ServletConfig

2、obtainFreshBeanFactory

​      AbstractRefreshableApplicationContext的实现包括createBeanFactory()(一般为DefaultListableBeanFactory)、loadBeanDefinitions()等。

3、prepareBeanFactory

配置beanFactory的基本属性，registerResolvableDependency注入依赖bean，registerSingleton注册单例bean等。

4、postProcessBeanFactory

子类实现；比如AbstractRefreshableWebApplicationContext，添加了ServletContextAwareProcessor，调用了WebApplicationContextUtils类注册了web相关的bean

5、invokeBeanFactoryPostProcessors

调用顺序大体为，开发手动注册的>容器内的，BeanDefinitionRegistryPostProcessor>BeanFactoryPostProcessor，PriorityOrdered>Ordered>其它未实现order接口的

其中BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor，虽为父子类，调用方法不同;BeanDefinitionRegistryPostProcessor的仅有的及代表性的实现类ConfigurationClassPostProcessor，用来解析@Configuration。postProcessBeanDefinitionRegistry先于postProcessBeanFactory的原因，前者用来创建bean定义（如ConfigurationClassPostProcessor，会通过@Configuration注解引入bean），后者用来修改BeanFactory或修改bean定义，为了确保修改之前所有的bean定义都存在，故有此先后顺序。



配置类的Full模式（会被enhance）和Lite模式

只有类上标注@Configuration才是full模式；标注@Component、@ComponentScan、@Import、@ImportResource或者啥注解都没标注但是有被标注了@Bean的方法这种也是lite模式。



番外:

步骤2loadBeanDefinitions()，委托给AnnotatedBeanDefinitionReader（注解）和ClassPathBeanDefinitionScanner（包扫描）来加载bean。两者都会通过调用AnnotationConfigUtils.registerAnnotationConfigProcessors往容器里注册一些内部bean，其中就包括ConfigurationClassPostProcessor（处理@Configuration）、AutowiredAnnotationBeanPostProcessor（处理如@Autowired）、RequiredAnnotationBeanPostProcessor（处理如@Required，可定制）、CommonAnnotationBeanPostProcessor（处理@PostConstruct、@PreDestroy、@Resource）、EventListenerMethodProcessor（处理@EventListener）



6、registerBeanPostProcessors

AbstractBeanFactory持有beanPostProcessors，唯一的添加入口为addBeanPostProcessor函数；在本步骤之前，已经往beanFactory里添加了部分BeanPostProcessor；在本步骤中，又会把容器中存在的BeanPostProcessor都add到beanPostProcessors里，以备后续执行。（其中ApplicationListenerDetector重新注册放到了最后）

调用PostProcessorRegistrationDelegate#registerBeanPostProcessors，从BeanFactory中取出所有BeanPostProcessor实例，（BeanPostProcessorChecker），先注册实现PriorityOrdered的BeanPostProcessor，再注册实现Ordered的BeanPostProcessor，再注册未实现以上接口的BeanPostProcessor，最后注册internalPostProcessors（实现了MergedBeanDefinitionPostProcessor，对@Autowired和@Value的支持依赖这个接口，参见AutowiredAnnotationBeanPostProcessor），（ApplicationListenerDetector）。

（要注意区分ApplicationContext和BeanFactory里的BeanPostProcessor区分，前者是放在map里的，后者有一个beanPostProcessors列表）

7、initMessageSource

注册一个MessageSource（暂不清楚这个类用处）

8、initApplicationEventMulticaster

注册一个ApplicationEventMulticaster，默认SimpleApplicationEventMulticaster（可以设置ErrorHandler，未设置时不会捕获异常须自行处理）

9、onRefresh

模板方法，给子类实现

10、registerListeners

和BeanPostProcessor类似，先注册手动添加的，再注册容器里的。

11、finishBeanFactoryInitialization

实例化大部分类的时刻。bean的定义不再变化，调用beanFactory.preInstantiateSingletons()，由DefaultListableBeanFactory实现该方法。

preInstantiateSingletons方法，non-lazy的非抽象单例通过getBean(beanName)方法获取，FactoryBean只有在isEagerInit时才会实例化；最后处理SmartInitializingSingleton的子类。

12、finishRefresh

一个重点是LifecycleProcessor的注册，一般为DefaultLifecycleProcessor，随后就执行了LifecycleProcessor的onFresh函数。另外就是发布ContextRefreshedEvent事件。

